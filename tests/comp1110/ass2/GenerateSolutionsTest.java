package comp1110.ass2;

import jdk.nashorn.internal.objects.NativeString;
import org.junit.Test;

import java.util.*;

import static comp1110.ass2.GenerateSolutions.*;
import static comp1110.ass2.Piece.ringCoords;
import static comp1110.ass2.StepsGame.isPiecePlacementWellFormed;
import static comp1110.ass2.TestUtility.SOLUTIONS_MULTI;
import static comp1110.ass2.TestUtility.SOLUTIONS_ONE;
import static comp1110.ass2.TestUtility.randomLocation;
import static comp1110.ass2.ValidStartPlacementMulti.filterByIsolatedTiles;
import static org.junit.Assert.*;

/**
 * Created by Daniel on 26/09/2017.
 */
//All tests for this class by Daniel Lai u6352900.
public class GenerateSolutionsTest {
    private static final int TOGGLE_ON_ALL_RULES = 0;
    private static final int TOGGLE_ON_RULES_ZERO_TO_TWO = 1;
    private static final int TOGGLE_ON_RULE_THREE_ONLY = 2;
    private static String CORNERS = "Lg";

    @Test
    /*Tests that all three letter combinations were generated by generateAllPieceStates method.
    *We should have 3200 unique encodings that are well-formed piece placements.
    *This represents all possible next moves at a given point in the game, and this pool is what will be filtered.
    * MAX_AVAILABLE_MOVES (holds 812 legal first moves) in GenerateSolutions class filters based on the rules implemented in BoardGUI Class.
    * Playing the game will reduce the number of moves; adding pieces to board adds constraints, hence the first moves represent the maximum
    * number of moves
    * Proper implementation of rules are checked via Steve's tests for tasks 5 and 6.*/
    public void testAllPieceStatesGenerated() {
        String s = generateAllPieceStates();
        List<String> triplets = parseTriplets(s);
        Set<String> tripletsSet = new HashSet<>();
        for(String t: triplets){
            tripletsSet.add(t);
        }

        int countTrue = 0;
        for(String t: tripletsSet){
            if(!isPiecePlacementWellFormed(t)){
                break;
            }
            else{countTrue = countTrue + 1;}

        }
        assertTrue("Does not generate all possible piece states (3 letter encodings)",
                s.length()/3 == 8*8*50 && countTrue == 8*8*50);
    }

    @Test
    public void testGetIsolatedTiles(){
        String[][] testCases = new String[][]{
                {"BGSAHQEFBGCgCDNHFlDAi", "ERUjru"}, //has empty tiles that are not isolated.
                {"EHSBHnFBgHGlABPGBiDCNCBL", "BHYdepu"} //has isoTile not adj any UR (see isSurrounded() in GenerateSolutions class)
        };
        for(int i = 0; i < testCases.length; i = i + 1) {
            Board b = updateBoardTo(testCases[i][0]);
            String correctAnswer = testCases[i][1];
            String yourAnswer = getIsolatedTiles(b);
            assertTrue("You returned nothing.", !yourAnswer.equals(""));
            assertTrue("You returned incorrect answer.", yourAnswer.equals(correctAnswer));
            if (!yourAnswer.equals(correctAnswer)) {
                    System.out.println("The correct answer is: " + correctAnswer + "."
                    + " your answer was: " + yourAnswer);
            }
        }
    }

/*TEST VALIDITY OF CORNER RULE:
Motivation: It's worth proving this rule since it dramatically reduces solve time.

    Corner rule: All valid solutions have 'L' OR 'g' occupied.
    IMPORTANT NOTE: Occupation can be by any ring, not just the home-ring/centre ring.

    (Replace 'L' with 'g' and use same reasoning below for 'g')
    'L' cannot be occupied precisely when all the below conditions hold:
         (1) unoccupied tiles in the 3x3 grid with 'L' as centre >= 5
         (2) 'L' is obstructed by an upper ring
         (3) 'L' is unoccupied
     These conditions formally state 'L' could be occupied but the obstruction prevents us from doing so.
     5 is chosen for (1) because we need at least 5 empty squares to put a piece (least number of rings in a piece is 5)

     I prove this with cornerRuleTestOne() and cornerRuleTestTwo().*/
    @Test
    public void cornerRuleValid(){
        assertTrue("Corner rule is invalid.", cornerRuleValidFirstTest() && cornerRuleValidSecondTest());
    }

    /*cornerRuleValidFirstTest() method tests:
    Claim: If 'L' and 'g' can never be occupied then all the tiles from the list
    'A', 'K', 'U', 'f', 'p', can never be occupied.
    My code does proof by contrapositive:
    There exists a tile from the list that is occupied and this implies 'L' or 'g' will be occupied.

    Why do we care?: We conclude that if both 'L' and 'g' are not occupied then we get 5 unreachable tiles on the board (must be blank by the endgame)
                    Now adding the fact that 'L' and 'g' cannot be occupied to the list we get 7 unreachable tiles.
                    The second part shows we must have 8 unreachable tiles, hence the game is impossible to solve
                    (An end game must have exactly 43 rings and 7 unreachable tiles.)*/

    public boolean cornerRuleValidFirstTest(){
        List<Character> testLocations = new ArrayList<>(Arrays.asList('A', 'K', 'U', 'f', 'p'));
        for(Character t: testLocations){
            List<String> nextMoves = filterMovesAt(maxAvailableMoves(), t);
            for(String move: nextMoves){
                Board b = updateBoardTo(move);
                if(cornerIsUnoccupied(b, 'L') && cornerIsUnoccupied(b, 'g')){
                    return false;
                }
            }
        }
        return true;
    }

        public boolean cornerIsUnoccupied(Board b, char corner){
            int cornerVal = b.getBoardState().get(corner);
            return cornerVal == 0 || cornerVal == 1;
        }

        //Return all next moves at a particular BoardGUI location
        public List<String> filterMovesAt(List<String> availableMoves, char loc){
            List<String> filteredMoves = new ArrayList<>();
            for(String move: availableMoves){
                if(move.charAt(2) == loc){
                    filteredMoves.add(move);
                }
            }
            return filteredMoves;
        }


    /*CornerRuleTestTwo():
       The question this algorithm answers is, can we make an end game state where 'A', 'K', 'U', 'f', 'p', 'L', and 'g' are all unoccupied,
       AND all other tiles are occupied.
       One way to answer this is to consider putting pieces along the vertical column 'C', 'M', 'W', 'H', 'r'.
      (1) First we find every possible combination of two pieces (placement) that can occupy this column such that 'L' and 'g' are unoccupied.
      (2) Next we find out if that 6 letter placement occupies all the tiles 'B', 'V', 'q'.
          This must be true, since we cannot have anymore unoccupied tiles (we already have 7).
      (3) We then test all moves satisfying (1) and (2) for valid solutions,
          We use an unfiltered solver that stops when the number of isolated tiles is greater than 7.

      */

    //STEP 1
    public List<String> getTestMoves(){
        List<Character> testLocations = new ArrayList<>(Arrays.asList('C', 'M', 'W', 'h', 'r'));

        List<String> legalMoves = new ArrayList<>();
        for(Character t: testLocations){
            List<String> nextMoves = filterMovesAt(maxAvailableMoves(), t);
            for(String move: nextMoves){
                Board b = updateBoardTo(move);
                //Step 1: Getting moves that do not lead to 'L' AND 'g' being occupied.
                if(cornerIsUnoccupied(b, 'L') && cornerIsUnoccupied(b, 'g')){
                    legalMoves.add(move);
                }
            }
        }
        return legalMoves;
    }

    public static boolean isOccupied(Board b, char loc){
        int tileVal = b.getBoardState().get(loc);
        return tileVal == 2 || tileVal == 3;
    }

    /*STEP 2
    Test shows only one possible placement satisfies this condition HEMFHh.
    Since HEM generates no isolated tiles, that do not overlap with 'C', 'M', 'W', 'h', 'r', we can put this on the board
    as a first move. Thus if we show 'HEM' has no solutions, then the corner rule must hold.
    */
    public List<String> getPlacementsSatisfyingConstraints(){
        List<Character> testLocations = new ArrayList<>(Arrays.asList('C', 'M', 'W', 'h', 'r'));
        List<Character> xs = new ArrayList<>(Arrays.asList('C', 'W', 'r'));
        List<Character> ys = new ArrayList<>(Arrays.asList('B', 'V', 'q'));
        List<String> nextMoves = getTestMoves();
        List<String> placementsSatisfyingConstraints = new ArrayList<>();

        //Cross the lists to get [3-letter] pairs where 'L' and 'g' are unoccupied.
        // Gets all possible pairings and orders of pairings.
        List<String> placements = new ArrayList<>();
        for(String moveOne: nextMoves) {
            for (String moveTwo : nextMoves) {
                placements.add(moveOne + moveTwo);
            }
        }
        for(String p: placements){
            Board b = updateBoardTo(p);
            boolean twoMovesPlayed = b.getMoveSequence().length() == 6;
            if(twoMovesPlayed){
                int count = 0;
                for(int i = 0; i < 3; i = i + 1){
                    if(isOccupied(b, ys.get(i))){
                        count = count + 1;
                    }
                }
                if(count == 3){
                    System.out.println("This placement " + p
                            + " satisfies 'B', 'V', 'q' all occupied " +
                            "and 'A', 'K', 'U', 'f', 'p', 'L', and 'g' are all unoccupied");
                    b.printOutBoardState();
                    System.out.println();
                    placementsSatisfyingConstraints.add(p);}
            }
        }
        System.out.println("There are " + placementsSatisfyingConstraints.size()
                + " placements that satisfy these constraints."
                + " all beggining with either 'HEM' or 'HEh'."
                + System.lineSeparator()
                + " 'HEM' and 'HEh' generate no isolated tiles outside of the locations 'A', 'K', 'U', 'f', 'p', 'L', and 'g'."
                + System.lineSeparator());

        return placementsSatisfyingConstraints;
    }

    /*STEP 3: Quick visual inspection shows "HEM" and "HEh generates no isolated tiles.
    So we start with this placement, and check if it has nextMoves without any filters.
    We draw from the max available moves excluding putting pieces at 'A', 'K', 'U', 'f', 'p', 'L', and 'g'.
    Test shows runs out of moves on the third move
    So this game state is invalid.*/
    public boolean cornerRuleValidSecondTest() {
        getPlacementsSatisfyingConstraints();
        String testLocations = "BCDEFGHIJMNOPQRSTVWXYabcdehijklmnoqrstuvwxy";
        List<String> testCases = new ArrayList<>(Arrays.asList("HEh", "HEM"));
        List<String> availableMoves;
        for(String testCase: testCases){
            for (int i = 0; i < testLocations.length(); i = i + 1) {
                availableMoves = filterMovesAt(maxAvailableMoves(), testLocations.charAt(i));
                Board b = updateBoardTo(testCase);
                List<String> nextMoves = getNextMovesUnfiltered(b, 2, filterByIsolatedTiles(b, availableMoves, 0));
                if (nextMoves.size() != 0) {
                    for (String move : nextMoves) {
                        b = updateBoardTo(move);
                        for (int j = 0; j < testLocations.length(); j = j + 1) {
                            availableMoves = filterMovesAt(maxAvailableMoves(), testLocations.charAt(j));
                            nextMoves = getNextMovesUnfiltered(b, 3, filterByIsolatedTiles(b, availableMoves, 0));
                            if (nextMoves.size() != 0) {
                                System.out.println(nextMoves);
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }



    //Checks corner rule properly implemented
    @Test
    public void allCornersValidTest(){
        List<String> falseTestCases = new ArrayList<>(Arrays.asList("EDN", "EAg"));
        List<String> trueTestCases = new ArrayList<>(Arrays.asList("EDj", "CDN"));
        List<String> mismatches = new ArrayList<>();

        for(String testCase: falseTestCases){
            Board b = updateBoardTo(testCase);
            if(allCornersValid(b) && b.getPiecesUsed().size() == 3){
                mismatches.add("Expected false for: " + testCase + ". Returned true.");
            }
        }

        for(String testCase: trueTestCases){
            Board b = updateBoardTo(testCase);
            if(!allCornersValid(b) && b.getPiecesUsed().size() == 3){
                mismatches.add("Expected true for: " + testCase + ". Returned false.");
            }
        }

        assertTrue("Valid corner test has failed.", mismatches.size() == 0);
    }


    /*Methods to get the next moves without any back or forward filtering.*/
    public static List<String> getNextMovesUnfiltered(Board initialState, int moveNum, List<String> availableMoves) {
        List<String> nextMoveSeq = new ArrayList<>();

        for (String move : availableMoves) {
            initialState.updateBoardState(stringToPieceState(move), TOGGLE_ON_ALL_RULES);
            String t = initialState.getMoveSequence();
            if (t.length() == moveNum * 3) {
                nextMoveSeq.add(t);
                initialState.removePiece(stringToPieceState(move));
            }
        }
        return (nextMoveSeq);
    }

    /*TESTING BACKWARD FILTERS: The purpose of these tests is to give criteria for 'good' backward filter*/
    /*Back-filtering occurs after a piece is played.*/
    @Test
    //Check ratio of incorrect branches removed by back-filter rules.
    public void backFilterEffeciency(){
        List<String> unfilteredMoves;
        List<String> filteredMoves;
        List<Double> efficiencyScores = new ArrayList<>();
        for(int i = 0; i < SOLUTIONS_MULTI.length; i = i + 1 ) {
            Board b = updateBoardTo(SOLUTIONS_MULTI[i][0]);

            int moveNum = SOLUTIONS_MULTI[i][0].length() / 3 + 1;
            List<String> maxAvailableMoves = maxAvailableMoves();

            unfilteredMoves = getNextMovesUnfiltered(b, moveNum, maxAvailableMoves);
            filteredMoves = getNextMoves(b, moveNum, maxAvailableMoves);
            /*Note getNextMoves includes forward filtering & back filtering,
            but we establish in 'TESTING FORWARD FILTERS' that the forward filters do not remove any branches;
            Hence any branches removed must be due to backfilters.*/

            double efficiency = (double) filteredMoves.size() / (double) unfilteredMoves.size();
            efficiencyScores.add(efficiency);
        }

        double effSum = 0;
        for(double d: efficiencyScores){
            effSum = effSum + d;
        }
        double avgEfficiency = effSum/efficiencyScores.size();
        System.out.println("The average efficiency of combined back filtering methods is: " + avgEfficiency
        + System.lineSeparator() + "Number of test cases: " + SOLUTIONS_MULTI.length
        + System.lineSeparator() + "Branching measured on move " + 4 + " after starting from a single node at move 3.");

        assertTrue("Backfilters do not on average remove >= 0.3 of the branches", avgEfficiency <= 0.7);
        System.out.println();

    }

    /*TESTING FORWARD FILTERS: The purpose of these tests is to give criteria for 'good' forward filter*/

    @Test
        /*DO FORWARD FILTERS REMOVE BRANCHES?*/
    /*I use back-filters to remove branches, because there is more information about
    whether the move is good or bad after its placed onto the board.
    So I expect my forward filters not to remove any branches.*/
    public void doesForwardFilterReduceNodesGen(){
        List<String> availableMoves = maxAvailableMoves();
        List<Double> branchRatios = new ArrayList<>();

        for(int i = 0; i < SOLUTIONS_MULTI.length; i = i + 1 ) {
            Board b = updateBoardTo(SOLUTIONS_MULTI[i][0]);
            List<String> filteredMoves = composedFilter(b, availableMoves);
            double branchesWithForwardFilter =(double)getNextMovesUnfiltered(b, 4, filteredMoves).size();
            double branchesWithoutForwardFilter =(double)getNextMovesUnfiltered(b, 4, availableMoves).size();
            double branchRatio = branchesWithForwardFilter/branchesWithoutForwardFilter;
            branchRatios.add(branchRatio);
        }

        double sum = 0;
        for(double d: branchRatios){
            sum = sum + d;
        }
        double avgEfficiency = sum/branchRatios.size();

        assertTrue("Forward filters DOES reduce branching from single node.", avgEfficiency == 1.0);
    }

    @Test
    /*Check proportion of moves removed by forward filter.
    Note removing a move does not remove any branch that the game rules already don't remove.
    This was established by the test in 'DO FORWARD FILTERS REMOVE BRANCHES?"
    However, forward filters mean we don't have to place the piece onto the board and check via game rules whether its valid.*/
    public void forwardFilterEfficiency(){
        List<String> availableMoves = maxAvailableMoves();
        List<Double> efficiencyScores = new ArrayList<>();
        for(int i = 0; i < SOLUTIONS_MULTI.length; i = i + 1 ) {
            Board b = updateBoardTo(SOLUTIONS_MULTI[i][0]);

            double efficiency = (double)composedFilter(b, availableMoves).size() / (double)availableMoves.size();
            efficiencyScores.add(efficiency);
        }

        double effSum = 0;
        for(double d: efficiencyScores){
            effSum = effSum + d;
        }
        double avgEfficiency = effSum/efficiencyScores.size();

        System.out.println("The average efficiency of combined forward filtering methods is: " + avgEfficiency
                + System.lineSeparator() + "Number of test cases: " + SOLUTIONS_MULTI.length
                + System.lineSeparator() + "Number of next possible moves measured for move " + 4);

        assertTrue("Forward filters do not on average remove >= 0.5 of possible next moves", avgEfficiency <= 0.5);
        System.out.println();
    }

    @Test
    /*DO FORWARD FILTERS SAVE TIME*/
    /*If forward filters don't reduce branching, then they must save time, by bypassing having to play the move.
    If not then these filters are not worth it.
    Note that in general forward filtering improves as more pieces are put on the board, and decreases with boards with fewer pieces;
    Because with more pieces are more constraints.
    I only test midway through the game at move 4 to provide a rough estimate that time is being reduced.
     but offers some measure of time saved.*/
    public void doesForwardFilterSaveTime(){
        List<String> availableMoves = maxAvailableMoves();

        double startTime = System.currentTimeMillis();
        for(int n = 0; n < 10; n = n + 1){
            for(int i = 0; i < SOLUTIONS_MULTI.length; i = i + 1 ) {
                Board b = updateBoardTo(SOLUTIONS_MULTI[i][0]);
                List<String> filteredMoves = composedFilter(b, availableMoves);
                getNextMovesUnfiltered(b, 4, filteredMoves);
            }
        }
        double endTime = System.currentTimeMillis();
        double filterTime = endTime - startTime;

        startTime = System.currentTimeMillis();
        for(int n = 0; n < 10; n = n + 1){
            for(int i = 0; i < SOLUTIONS_MULTI.length; i = i + 1 ) {
                Board b = updateBoardTo(SOLUTIONS_MULTI[i][0]);
                List<String> filteredMoves = availableMoves;
                getNextMovesUnfiltered(b, 4, availableMoves);
            }
        }
        endTime = System.currentTimeMillis();
        double noFilterTime = endTime - startTime;

            System.out.println("Time taken to generate next branches with filtering: " + filterTime + System.lineSeparator()
                            + "Time taken to generate next branches without filtering: " + System.lineSeparator()
                            + noFilterTime + System.lineSeparator()
                            + "Ratio: " + filterTime/noFilterTime);

        assertTrue("Execution efficiency not reduced at all.", filterTime/noFilterTime <= 1.0);
    }

    /*NOTE: composedFilter takes all forward filters used in myGetSolutions() method, and composes them.*/
    public static List<String> composedFilter(Board initialState ,List<String> availableMoves){
        return filterBySearchRegions(initialState, filterMovesByPiecesUsed(initialState, availableMoves));
    }
}